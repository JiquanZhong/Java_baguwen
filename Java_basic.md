## 基础概念和常识

### Java有哪些特点

1. 简单易学
2. 面向对象
3. 平台无关性
4. 支持多线程
5. 可靠性
6. 安全性
7. 支持网络编程
8. 编译与解释并存

### JVM vs JDK vs JRE

Java虚拟机（JVM）就是运行Java字节码的虚拟机。JVM针对不同系统有不同的实现，目的是对应相同的字节码都能给出相同的运行结果。字节码和不同的JVM实现是Java“write once run everywhere”的关键。JVM是一种规范，具体实现有很多种，如HotSpot，J9 VM，Zing VM，JRockit VM等。

JDK是Java Development Kit的缩写，即Java开发工具包。它包含了JRE，同时还有编译器javac和工具（javadoc和jdb）。

JRE是Java Runtime Environment等缩写，即Java运行时环境。如果只是为了运行字节码文件，那么安装JRE就够了。但有特例，使用JSP部署Web应用等时候，因为应用程序服务器会将JSP转换为Java Servlet，需要使用JDK编译servlet。

### 什么是字节码？采用字节码的好处是什么？

JVM可以理解的代码就叫字节码，它的扩展名为.class。字节码不面向任何处理器，只面向JVM。Java通过字节码的方式，在一定程度上解决了解释型语言效率低的问题，同时又保留了解释型语言可移植的优势。

### 为什么不全部使用AOT（提前编译）？

AOT可以提前编译节省时间，为什么全部使用这种方式的原因是：Java是具有动态特性的语言。举个例子，CGLIB动态代理技术使用的是ASM技术，这种技术的运行原理是运行时直接在内存中生成并加载修改后的字节码文件。如果全部使用AOT提前编译，就不能使用ASM技术了。

### 为什么说 Java 语言“编译与解释并存”？

高级编程语言按照执行方式可以分为两种

* 编译性：编译型语言会通过编译器一次性把源代码翻译成机器码。一般而言，编译型的开发效率慢，但执行效率高，如C，C++，Go，Rust等
* 解释性：解释型语言会通过解释器逐行将代码解释成机器码后再执行，解释型语言的开发效率快，但执行效率低，如Python，Javascript，PHP等

Java程序从源代码到运行的过程如图所示：

![Java程序转变为机器代码的过程](https://camo.githubusercontent.com/2787b36c8b7086423ee62ddea4dbf085b40b89499a420273716a6abc43494117/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f6a6176612f62617369732f6a6176612d636f64652d746f2d6d616368696e652d636f64652e706e67)

其中.class->机器可理解的代码这一步，JVM会把字节码先加在进虚拟机，然后通过解释器逐行解释运行，这种运行方式相对较慢。但是，有些方法和代码块需要经常被调用，所以后面引入了Just-In-Time即时编译器，它属于运行时编译。当JIT第一次完成编译后，会把字节码对应的机器码保存下来，下次就可以直接使用。而机器码的执行效率是高于Java解释器的，所以这就为什么我们说“Java是编译与解释共存的语言”。

### Java和C++的区别

Java和C++都是面向对象语言，支持封装，多态和继承，但他们还有很多不同的地方：

* Java不提供指针访问内存，内存更安全
* Java的类是单继承的，C++支持多继承。但Java可以使用接口实现多继承
* Java有内存回收机制（GC）不需要程序员手动释放内存
* C++支持操作符和方法的重载，而Java只支持方法的重载
* ......

### Java我注释有哪几种

Java注释一共有三种：

* 单行注释：//开头至行尾，用于解释方法内某单行代码的功能
* 多行注释：/*开头  */结尾，用于解释某一段代码的功能
* 文档注释：用于生成Java开发文档

### 标识符和关键字的区别是什么

标识符：当我们编程时，需要大量地为程序、类、变量、方法取名字。标识符就是这种名字。

关键字：有些标识符，Java已经为其赋予了特殊的含义，只能用于特殊的地方。所有的关键字都是小写，载IDEA中会有特殊的颜色。

### Java关键子有哪些？

| 分类                 | 关键字   |            |          |              |            |           |        |
| -------------------- | -------- | ---------- | -------- | ------------ | ---------- | --------- | ------ |
| 访问控制             | private  | protected  | public   |              |            |           |        |
| 类，方法和变量修饰符 | abstract | class      | extends  | final        | implements | interface | native |
|                      | new      | static     | strictfp | synchronized | transient  | volatile  | enum   |
| 程序控制             | break    | continue   | return   | do           | while      | if        | else   |
|                      | for      | instanceof | switch   | case         | default    | assert    |        |
| 错误处理             | try      | catch      | throw    | throws       | finally    |           |        |
| 包相关               | import   | package    |          |              |            |           |        |
| 基本类型             | boolean  | byte       | char     | double       | float      | int       | long   |
|                      | short    |            |          |              |            |           |        |
| 变量引用             | super    | this       | void     |              |            |           |        |
| 保留字               | goto     | const      |          |              |            |           |        |

### Continue、break和return的区别是什么？

continue：跳出当前这一次循环，继续下一次循环

break：跳出整个循环体，继续执行下面的语句

return：跳出所在方法，结束该方法的运行

### 成员变量与局部变量的区别

语法形式：成员变量属于类，而局部变量是代码块或方法中定义的变量或是方法的参数；成员变量可以被public，private，static等修饰符修饰，而局部变量不能被访问控制符以及static修饰。但是，成员变量和局部变量都能被final修饰

储存空间：如果成员变量被static修饰，那么它就是属于类的，如果没有使用static修饰，就属于实例的，而实例对象储存在堆空间。局部变量则在栈空间

生存时间：成员变量随着对象创建而存在，与对象生命一样。而局部变量随着方法调用生成，调用结束则消失

默认值：成员变量如果没有被赋值，则会被赋系统的默认值（final除外，因为final必须被显式赋值）。局部变量则不会被自动赋值

### 静态变量有什么作用

静态变量被类的所有实例共享，无论一个类有多少个实例，它们都有同一份静态变量

一般来讲，静态变量会被final关键字修饰

### 静态方法为什么不能调用非静态成员

结合JVM相关知识，原因如下：

1. 静态方法属于类，在类加载的时候就会分配内存，可以通过类名直接访问。非静态成员属于实例对象，只有在对象实例化后才能通过实例访问。
2. 在非静态成员不存在的时候，静态成员就存在了。调用内存中还不存在的东西属于非法操作。

### 重载和重写有什么区别

重载：发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰可以不同。简而言之，重载就是同一个类中doge同名方法根据不同传参执行不同的逻辑处理。

重写：发生在运行期，是子类对父类方法的实现过程进行重新编写。

1. 方法名，参数列表必须相等。子类方法返回值必须小于等于父类方法。抛出的异常范围小于等于父类方法。访问修饰范围大于等于父类。
2. 如果父类方法被访问修饰符private、final、static修饰，则子类不能重写该方法。但被static修饰的方法能够被再次声名。
3. 构造方法无法被重写。

| 区别       | 重载方法 | 重写方法                                   |
| ---------- | -------- | ------------------------------------------ |
| 发生范围   | 同一个类 | 子类                                       |
| 参数列表   | 必须修改 | 一定不能修改                               |
| 返回类型   | 可修改   | 子类方法返回值范围小于等于父类方法返回值   |
| 异常       | 可修改   | 子类方法抛出异常的范围小于等于父类方法异常 |
| 访问修饰符 | 可修改   | 一定不能做更严格的修改                     |
| 发生阶段   | 编译期   | 运行期                                     |

记忆：方法的重写遵循“两同两小一大”

* 两同：方法名，参数列表相同
* 两小：子类方法返回值比父类的范围小，子类抛出异常的范围比父类的小
* 一大：子类方法的访问权限比父类方法的大

### Java中有几种基本数据类型？

Java中有八种基本数据类型：

* 六种数字型：
  * 4种整数型：byte, short, int, long
  * 2种浮点型：float, double
* 一种字符型：char
* 一种布尔：boolean

| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   |
| --------- | ---- | ---- | ------- | ------------------------------------------ |
| `byte`    | 8    | 1    | 0       | -128 ~ 127                                 |
| `short`   | 16   | 2    | 0       | -32768 ~ 32767                             |
| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                   |
| `long`    | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |
| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535                                  |
| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |
| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |
| `boolean` | 1    |      | false   | true、false                                |

注：使用long一定要在后面加上L，否则被当作int解析

这八种基本数据类型对应的包装类为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean`。

### 基本类型和包装类型的区别

1. 成员变量包装类型不赋值就是null，而基本类型有默认值
2. 包装类型可用于泛型，而基本类型不可以
3. 基本数据类型的局部变量存放载Java虚拟机栈的局部变量表中，成员变量（未被static修饰）放在Java虚拟机的堆中。包装类属于对象类型，放在堆中
4. 相比于对象类型，基本数据类型占用的空间更小

### 包装类型的缓存机制

Java的包装类型除了`Float`、`Double`都有缓存机制。具体实现为：`Byte`、`Short`、`Integer`、`Long`默认创建了**[-128，127]** 的相应类型的缓存数据。`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。如果超出了缓存范围则会创建新的对象。

`Integer i1=40` 这一行代码会发生装箱，也就是说这行代码等价于 `Integer i1=Integer.valueOf(40)` 。因此，`i1` 直接使用的是缓存中的对象。而`Integer i2 = new Integer(40)` 会直接创建新的对象。

### 自动拆箱和装箱了解吗？原理是什么？

自动装箱：将基本数据类型用对应的包装类包装起来

自动拆箱：将包装类转换为基本数据类型

自动装箱实际上就是调用了包装类的valueOf方法。拆箱就是调用了xxxValue方法。如：

* `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`
* `int n = i`等价于`int n = i.intValue()`

频繁装箱拆箱会影响性能，我们要尽量避免不必要的装箱和拆箱。

### 为什么浮点运算有精度丢失的风险？

这和计算机保存符点数的机制有关。计算机是二进制的，而计算机载表示一个数字的时候，宽度有限，无限循环小数储存在计算机只能被截，所以就会发生精度丢失的情况，所以符点数没有办法用二进制精确表示。

如二进制无法精确表示1/10。

### 如何解决浮点运算的精度丢失问题？

`BigDecimal`可以实现对浮点数的运算，不会造成精度丢失。大部分涉及到符点数精确运算的业务场景都是使用的`BigDecimal`。

### 超过long整型都数据应该如何表示？

基本数据类型都有一个数值范围，超过这个范围则有数值溢出的风险。在这种情况下，我们可以使用`BigInteger`储存数据，`BigInteger`内部使用`int[]`来储存任意大小的整型数据。但其运算效率比较低。

### 面向对象和面向过程的区别

两者的主要区别在于解决问题的思路不同：

* 面向过程把解决问题的过程拆解成一个个方法，然后通过这些方法的执行来解决问题
* 面向对象先把业务涉及的对象抽离出来，然后通过执行对象的方法解决问题

面向对象开发的程序更易维护，代码易复用，易扩展。

### 创建一个对象用什么运算符？对象实例与对象引用有什么不同

创建一个对象使用new关键字。new在堆空间中创建对象实例，而对象引用储存的是对象实例的地址，该引用存放在栈空间中。

一个对象引用可以指向0或1个对象实例。而一个对象实例可以被多个对象引用指向。

### 对象相等和引用相等的区别

* 对象相等指的是内存中存放的内容是否相等
* 引用相等指的是它们指向的地址是否相等

### 如果一个类没有声明构造方法，能被正确执行吗？

如果一个类没有声明构造方法，系统会赠送一个无参构造方法。如果声明了构造方法，系统便不会再赠送任何构造方法。所以当我们重载了有参构造法，需要把无参构造法补上。

### 构造方法有哪些特点？是否能被override？

构造方法有如下特点：

* 名字与类名相同
* 无返回值
* 无需被调用，在new对象实例时会自动调用

构造方法不能被override，但可以被overload，可以看到一个类有多种参数构造器的情况

### 面相对象的三大特征

三大特征：

* 封装：把对象的信息隐藏在类内部，不允许外置对象直接访问。但是可以提供方法来操作属性。

* 继承：不同类型的对象有一定数量的相同点。我们可以把相同点抽离出来定义成父类。使用继承可以快速创建我们需要的类。使用继承可提高代码的复用性，程序的可维护性，提高开发效率

  继承有如下特点：

  1. 子类拥有父类的所有属性和方法（包括私有方法和属性）。（但子类无法访问父类的私有属性和方法，只能拥有）
  2. 子类可以拥有父类没有的属性和方法
  3. 子类可以重写父类的方法

* 多态：指一个对象有多种状态。具体表现为父类引用指向子类对象。

  多态有如下特点：

  1. 对象实例和引用类型之间有继承或实现的关系
  2. 引用类型具体调用哪个方法，必须在程序运行期间才能确定
  3. 多态不能调用“存在子类但不存在于父类”的方法
  4. 如果子类重写了父类的方法，真正执行的是子类的方法。如果子类没有重写方法，执行的则是父类的方法

### 接口和抽象类的异同

共同点：

* 都不能被实例化，但可以创建该类的引用
* 都可以包含抽象方法，且子类必须实现这些抽象方法

不同点：

* 接口只能包含抽象方法的默认方法，不能为其提供实现。抽象类则可以包含具体的实现方法
* 接口不能定义静态方法。抽象类则可以定义静态方法
* 一个类只能继承一个类，但可以实现多个接口
* 接口中的成员变量只能是public static final类型，不能被修改且要有初始值。抽象类成员变量默认为default可以在子类中被重新定义，也可以被重新赋值
* 接口不能有构造器。抽象类可以包含构造器。
* 接口不能包含初始化代码块，抽象类可以包含初始化代码块。

### 浅拷贝 vs 深拷贝 vs 引用拷贝

浅拷贝：在堆上创建一个新的对象，但对象内部发引用属性指向原有对象的属性地址。

深拷贝：在堆上创建一个新的对象，对象内部的引用属性指向新创建的属性对象。

引用拷贝：创建一个引用变量，指向原有对象的地址。

![浅拷贝、深拷贝、引用拷贝示意图](https://camo.githubusercontent.com/5734db876243a6b72a80b3cef8584e26fdd8a8c963cc1afaedffdb1f43b73820/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f6a6176612f62617369732f7368616c6c6f7726646565702d636f70792e706e67)

### 如何深拷贝？

类需要实现Cloneable接口并实现`clone()`方法。如果没实现`clone()`方法，则调用的是Object类中的`clone()`方法。

具体例子如下：

假设Person有一个引用属性为birthday。对于实现Person的深拷贝，我们需要实现Cloneable接口中的`clone()`，具体为：

1. `Person person = (Person) super.clone()`实现该类对象的拷贝。
2. 调用`person.setBirthday(this.getBirthday.clone())`
3. return person

